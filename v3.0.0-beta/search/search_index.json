{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Introduction to utPLSQL \u00b6 utPLSQL is a Unit Testing framework for Oracle PL/SQL. The framework follows industry standards and best patterns of modern Unit Testing frameworks like JUnit and RSpec User Guide Installation Getting Started Annotations Expectations Running unit tests Using the ut_run script Testing best pracitces Upgrade utPLSQL Reporting Using reporters Reporting errors Code coverage About Project Details License Support Authors Contributing Three steps \u00b6 With just three simple steps you can define and run your unit tests for PLSQL code. Install the utPLSQL framework Create Unit Tests to for the code Run the tests Here is how you can simply create tested code, unit tests and execute the tests using SQL Developer Check out the sections on annotations and expectations to see how to define your tests. Command line \u00b6 The ut_run.sql script is a powerful thing - it can provide output from the tests on the fly. You can also use it to have coloured output from the test, and if you try to test code that was dropper, all of unit tests related to that code will fail. Look into ut_run.sql script options to see more. Coverage \u00b6 If you want to have code coverage gathered on your code , it's best to use ut_run.sql to execute your tests with multiple reporters and have both test execution report as well as coverage report saved to a file. Check out the coverage documentation for options of coverage reporting","title":"Introduction to utPLSQL"},{"location":"index.html#introduction-to-utplsql","text":"utPLSQL is a Unit Testing framework for Oracle PL/SQL. The framework follows industry standards and best patterns of modern Unit Testing frameworks like JUnit and RSpec User Guide Installation Getting Started Annotations Expectations Running unit tests Using the ut_run script Testing best pracitces Upgrade utPLSQL Reporting Using reporters Reporting errors Code coverage About Project Details License Support Authors Contributing","title":"Introduction to utPLSQL"},{"location":"index.html#three-steps","text":"With just three simple steps you can define and run your unit tests for PLSQL code. Install the utPLSQL framework Create Unit Tests to for the code Run the tests Here is how you can simply create tested code, unit tests and execute the tests using SQL Developer Check out the sections on annotations and expectations to see how to define your tests.","title":"Three steps"},{"location":"index.html#command-line","text":"The ut_run.sql script is a powerful thing - it can provide output from the tests on the fly. You can also use it to have coloured output from the test, and if you try to test code that was dropper, all of unit tests related to that code will fail. Look into ut_run.sql script options to see more.","title":"Command line"},{"location":"index.html#coverage","text":"If you want to have code coverage gathered on your code , it's best to use ut_run.sql to execute your tests with multiple reporters and have both test execution report as well as coverage report saved to a file. Check out the coverage documentation for options of coverage reporting","title":"Coverage"},{"location":"about/CONTRIBUTING.html","text":"How to contribute \u00b6 The following are the guidelines, everyone should use to contribute to utPLSQL. Changes are welcome from all members of the Community. Getting Started \u00b6 Create a GitHub Account . Fork the utPLSQL Repository and setup your local Repository. Each of the steps below are detailed in the How to Fork article! Clone your Fork to your local machine. Configure \"upstream\" remote to the master utPLSQL repository . Update the git submodules by issuing command: git submodule update --remote --merge For each change you want to make: Create a new branch for your change. Make your change in your new branch. Although changes can be made in the master branch, it easier long term if a new branch is used. Make sure your change is covered with unit tests and/or is represented in examples Verify code compiles and all existing and new unit tests pass. The quickest way to have a Pull Request not be accepted, is to submit code that does not compile or pass tests. Commit change to your local repository. Push change to your remote repository Submit a Pull Request . Note: local and remote branches can be deleted after pull request has been accepted. Note: Getting changes from others requires Syncing your Local repository with Master utPLSQL repository. This can happen at any time. Coding Standards \u00b6 Snake case will be used. This separates keywords in names with underscores. execute_test All names will be lower case. Prefixes: Arguments to procedures and functions will start with a_ an Example would be procedure is_valid(a_owner_name varchar2); Object types and packages will start with ut_ Local variables l_ Global variables g_ Global Constants start with gc_ Types in packages, objects start with t_ Nested Tables start with tt_ varchar2 lengths are set in characters not bytes New to GIT \u00b6 If you are new to GIT here are some links to help you with understanding how it works. GIT Documentation Atlassian Git Tutorial What are other resources for learning Git and GitHub","title":"Contributing"},{"location":"about/CONTRIBUTING.html#how-to-contribute","text":"The following are the guidelines, everyone should use to contribute to utPLSQL. Changes are welcome from all members of the Community.","title":"How to contribute"},{"location":"about/CONTRIBUTING.html#getting-started","text":"Create a GitHub Account . Fork the utPLSQL Repository and setup your local Repository. Each of the steps below are detailed in the How to Fork article! Clone your Fork to your local machine. Configure \"upstream\" remote to the master utPLSQL repository . Update the git submodules by issuing command: git submodule update --remote --merge For each change you want to make: Create a new branch for your change. Make your change in your new branch. Although changes can be made in the master branch, it easier long term if a new branch is used. Make sure your change is covered with unit tests and/or is represented in examples Verify code compiles and all existing and new unit tests pass. The quickest way to have a Pull Request not be accepted, is to submit code that does not compile or pass tests. Commit change to your local repository. Push change to your remote repository Submit a Pull Request . Note: local and remote branches can be deleted after pull request has been accepted. Note: Getting changes from others requires Syncing your Local repository with Master utPLSQL repository. This can happen at any time.","title":"Getting Started"},{"location":"about/CONTRIBUTING.html#coding-standards","text":"Snake case will be used. This separates keywords in names with underscores. execute_test All names will be lower case. Prefixes: Arguments to procedures and functions will start with a_ an Example would be procedure is_valid(a_owner_name varchar2); Object types and packages will start with ut_ Local variables l_ Global variables g_ Global Constants start with gc_ Types in packages, objects start with t_ Nested Tables start with tt_ varchar2 lengths are set in characters not bytes","title":"Coding Standards"},{"location":"about/CONTRIBUTING.html#new-to-git","text":"If you are new to GIT here are some links to help you with understanding how it works. GIT Documentation Atlassian Git Tutorial What are other resources for learning Git and GitHub","title":"New to GIT"},{"location":"about/authors.html","text":"Version 3 Major Contributors \u00b6 Listed Alphabetically Name GitHub account David Pyke Shoelace Jacek Gebal jgebal Pavel Kaplya Pazus Robert Love rlove Special thanks to prior major contributors. \u00b6 Steven Feuerstein - Original Author Chris Rimmer Patrick Barel Paul Walker","title":"Authors"},{"location":"about/authors.html#version-3-major-contributors","text":"Listed Alphabetically Name GitHub account David Pyke Shoelace Jacek Gebal jgebal Pavel Kaplya Pazus Robert Love rlove","title":"Version 3 Major Contributors"},{"location":"about/authors.html#special-thanks-to-prior-major-contributors","text":"Steven Feuerstein - Original Author Chris Rimmer Patrick Barel Paul Walker","title":"Special thanks to prior major contributors."},{"location":"about/license.html","text":"Version Information \u00b6 utPLSQL version 3 is licensed under [Apache 2.0] (https://www.apache.org/licenses/LICENSE-2.0) External code used in the development of this project, but is not required for use. Tool License Purpose Travis-Oracle ISC Install Oracle for Travis Builds mkDocs BSD Produce HTML version of documentation Note: Version 1 & 2 of utPLSQL were licensed under GPL, version 3 was a complete rewrite from scratch which a allowed us to change the license to a more permissive license.","title":"License"},{"location":"about/license.html#version-information","text":"utPLSQL version 3 is licensed under [Apache 2.0] (https://www.apache.org/licenses/LICENSE-2.0) External code used in the development of this project, but is not required for use. Tool License Purpose Travis-Oracle ISC Install Oracle for Travis Builds mkDocs BSD Produce HTML version of documentation Note: Version 1 & 2 of utPLSQL were licensed under GPL, version 3 was a complete rewrite from scratch which a allowed us to change the license to a more permissive license.","title":"Version Information"},{"location":"about/project-details.html","text":"utPLSQL Project Details \u00b6 utPLSQL is hosted on hosted on GitHub and open source project. Community help on this project is always appreciated, if your interested in helping please read our guide to contributing","title":"Project Details"},{"location":"about/project-details.html#utplsql-project-details","text":"utPLSQL is hosted on hosted on GitHub and open source project. Community help on this project is always appreciated, if your interested in helping please read our guide to contributing","title":"utPLSQL Project Details"},{"location":"about/support.html","text":"How to get support \u00b6 Feel free post questions, bugs or issues]to the issues area of GitHub . Join developers the utPLSQL team on Slack","title":"Support"},{"location":"about/support.html#how-to-get-support","text":"Feel free post questions, bugs or issues]to the issues area of GitHub . Join developers the utPLSQL team on Slack","title":"How to get support"},{"location":"userguide/annotations.html","text":"Annotations \u00b6 Annotations provide a way to configure tests and suites in a declarative way similar to modern OOP languages. This way th behavior of tests stored along with the test logic, versioned using VCS with the code under test. No configuration files or tables are needed. The annotation list is based on popular testing frameworks such as jUnit 5 and RSpec. The framework runner searches for all the suitable annotated packages, automatically configures suites, forms suites hierarchy, executes it and reports results in differet formats. Annotations are case-insensitive. But it is recommended to use the lower-case standard as described in the documentation. There are two places where annotations may appear: at the beginning of the package specification ( %suite , %suitepath etc) and right before a procedure ( %test , %beforeall , %beforeeach etc). Package level annotations are separated by at least one empty line from the following procedure annotations. Procedure annotetions are defined right before the procedure they reference, no empty lines allowed. If a package conatins %suite annotation in its specification part it is treated as a test package and processed by the framework. Some annotations accept parameters like %suite , %test %displayname , then the values are provided without any quatation marks, parameters are separated by commas. Example of annotated test package \u00b6 create or replace package test_pkg is -- %suite(Name of suite) -- %suitepath(all.globaltests) -- %beforeall procedure globalsetup ; -- %afterall procedure global_teardown ; /* Such comments are allowed */ -- %test -- %displayname(Name of test1) procedure test1 ; -- %test(Name of test2) -- %beforetest(setup_test1) -- %aftertest(teardown_test1) procedure test2 ; -- %test -- %displayname(Name of test3) -- %disabled procedure test3 ; -- %test(Name of test4) -- %rollback(manual) procedure test4 ; procedure setup_test1 ; procedure teardown_test1 ; -- %beforeeach procedure setup ; -- %aftereach procedure teardown ; end test_pkg ; Annotations description \u00b6 Annotation Level Description %suite(<description>) Package Marks package to be a suite of tests This way all testing packages might be found in a schema. Optional schema discription can by provided, similar to %displayname annotation. %suitepath(<path>) Package Similar to java package. The annotation allows logical grouping of suites into hierarchies. %displayname(<description>) Package/procedure Human-familiar description of the suite/test. Syntax is based on jUnit annotation: %displayname(Name of the suite/test) %test(<description>) Procedure Denotes that a method is a test method. Optional test description can by provided, similar to %displayname annotation. %beforeall Procedure Denotes that the annotated procedure should be executed once before all elements of the current suite. %afterall Procedure Denotes that the annotated procedure should be executed once after all elements of the current suite. %beforeeach Procedure Denotes that the annotated procedure should be executed before each %test method in the current suite. %aftereach Procedure Denotes that the annotated procedure should be executed after each %test method in the current suite. %beforetest(<procedure_name>) Procedure Denotes that mentioned procedure should be executed before the annotated %test procedure. %aftertest(<procedure_name>) Procedure Denotes that mentioned procedure should be executed after the annotated %test procedure. %rollback(<type>) Package/procedure Configure transaction control behaviour (type). Supported values: auto (default) - A savepoint is created before invocation of each \"before block\" is and a rollback to specific savepoint is issued after each \"after\" block; manual - rollback is never issued automatically. Property can be overridden for child element (test in suite) %disabled Package/procedure Used to disable a suite or a test Using automatic rollbacks in tests \u00b6 By default, every test is isolated from other tests using savepoint. This solution is suitable for use-cases, where the code that is getting tested as well as the unit tests themselves do not use transaction control commands (commit/rollback). In general, your unit tests should not use transaction control as long as the core you are testing is not using it too. Keeping the transactions uncommitted allows your changes to be isolated and the execution of tests is not impacting others that might be using a shared (integration) development database. If however you're in situation, where the code you are testing, is using transaction control (like ETL code is usually doing), then your tests should not use the default rollback(auto) You should make sure that thr entire suitepath all the way to the root is using manual transaction control in that case. In some cases it is needed to perform DDL in setup/teardown. It is recommended to move such DDL statements to a procedure with pragma autonomous_transaction to eliminate implicit commit of the main session. Suitepath concept \u00b6 It is very likely that the application for which you are going to introduce tests consists of many different packages or procedures/functions. Usually procedures can be logically grouped inside a package, there also might be several logical groups of procedure in a single package or even packages themselves might relate to a common module. Lets say you have a complex insurance application the operates with policies, claims and payments. The payment module contains several packages for payment recognition, charging, planning etc. The payment recognition module among others contains a complex recognize_payment procedure that associates received money to the policies. If you want to create tests for your application it is recommended to structure your tests similarly to the logical structure of you application. So you end up with something like: * Integration tests * Policy tests * Claim tests * Payment tests * Payments recognition * Payments set off * Payouts The %suitepath annotation is used for such grouping. Even though test packages are defined in a flat structure the %suitepath is used by the framework to form a hierarchical structure of them. Your payments recognition test package might look like: create or replace package test_payment_recognition as -- %suite(Payment recognition tests) -- %suitepath(payments) -- %test(Recognize payment by policy number) procedure test_recognize_by_num ; -- %test -- %displayname(Recognize payment by payment purpose) procedure test_recognize_by_purpose ; -- %test(Recognize payment by customer) procedure test_recognize_by_customer ; end test_payment_recognition ; And payments set off test package: create or replace package test_payment_set_off as -- %suite(Payment set off tests) -- %suitepath(payments) -- %test(Set off creation test) procedure test_create_set_off ; -- %test -- %displayname(Set off annulation test) procedure test_annulate_set_off ; end test_payment_set_off ; When you execute tests for your application, the framework constructs test suite for each test package. Then in combines suites into grouping suites by the %suitepath annotation value so that the fully qualified path to the recognize_by_num procedure is USER:payments.test_payment_recognition.test_recognize_by_num . If any of its expectations fails then the test is marked as failed, also the test_payment_recognition suite, the parent suite payments and the whole run is marked as failed. The test report indicates which expectation has failed on the payments module. The payments recognition submodule is causing the failure as recognize_by_num has is not meeting the expectations of the test. Grouping tests into modules and submodules using the %suitepath annotation allows you to logically organize your projects flat structure of packages int functional groups. Additional advantage of such grouping is the fact that every element level of the grouping can be an actual unit test package containing module level common setup for all of the submodules. So in addition to the packages mentioned above you could have following package. create or replace package payments as -- %suite(Payments) -- %beforeall procedure set_common_payments_data ; -- %afterall procedure reset_common_paymnets_data ; end payments ; A %suitepath can be provided in tree ways: * schema - execute all test in the schema * [schema]:suite1[.suite2][.suite3]...[.procedure] - execute all tests in all suites from suite1[.suite2][.suite3]...[.procedure] path. If schema is not provided, then current schema is used. Example: :all.rooms_tests . * [schema.]package[.procedure] - execute all tests in the test package provided. The whole hierarchy of suites in the schema is build before, all before/after hooks of partn suites for th provided suite package are executed as well. Example: tests.test_contact.test_last_name_validator or simply test_contact.test_last_name_validator if tests is the current schema.","title":"Annotations"},{"location":"userguide/annotations.html#annotations","text":"Annotations provide a way to configure tests and suites in a declarative way similar to modern OOP languages. This way th behavior of tests stored along with the test logic, versioned using VCS with the code under test. No configuration files or tables are needed. The annotation list is based on popular testing frameworks such as jUnit 5 and RSpec. The framework runner searches for all the suitable annotated packages, automatically configures suites, forms suites hierarchy, executes it and reports results in differet formats. Annotations are case-insensitive. But it is recommended to use the lower-case standard as described in the documentation. There are two places where annotations may appear: at the beginning of the package specification ( %suite , %suitepath etc) and right before a procedure ( %test , %beforeall , %beforeeach etc). Package level annotations are separated by at least one empty line from the following procedure annotations. Procedure annotetions are defined right before the procedure they reference, no empty lines allowed. If a package conatins %suite annotation in its specification part it is treated as a test package and processed by the framework. Some annotations accept parameters like %suite , %test %displayname , then the values are provided without any quatation marks, parameters are separated by commas.","title":"Annotations"},{"location":"userguide/annotations.html#example-of-annotated-test-package","text":"create or replace package test_pkg is -- %suite(Name of suite) -- %suitepath(all.globaltests) -- %beforeall procedure globalsetup ; -- %afterall procedure global_teardown ; /* Such comments are allowed */ -- %test -- %displayname(Name of test1) procedure test1 ; -- %test(Name of test2) -- %beforetest(setup_test1) -- %aftertest(teardown_test1) procedure test2 ; -- %test -- %displayname(Name of test3) -- %disabled procedure test3 ; -- %test(Name of test4) -- %rollback(manual) procedure test4 ; procedure setup_test1 ; procedure teardown_test1 ; -- %beforeeach procedure setup ; -- %aftereach procedure teardown ; end test_pkg ;","title":"Example of annotated test package"},{"location":"userguide/annotations.html#annotations-description","text":"Annotation Level Description %suite(<description>) Package Marks package to be a suite of tests This way all testing packages might be found in a schema. Optional schema discription can by provided, similar to %displayname annotation. %suitepath(<path>) Package Similar to java package. The annotation allows logical grouping of suites into hierarchies. %displayname(<description>) Package/procedure Human-familiar description of the suite/test. Syntax is based on jUnit annotation: %displayname(Name of the suite/test) %test(<description>) Procedure Denotes that a method is a test method. Optional test description can by provided, similar to %displayname annotation. %beforeall Procedure Denotes that the annotated procedure should be executed once before all elements of the current suite. %afterall Procedure Denotes that the annotated procedure should be executed once after all elements of the current suite. %beforeeach Procedure Denotes that the annotated procedure should be executed before each %test method in the current suite. %aftereach Procedure Denotes that the annotated procedure should be executed after each %test method in the current suite. %beforetest(<procedure_name>) Procedure Denotes that mentioned procedure should be executed before the annotated %test procedure. %aftertest(<procedure_name>) Procedure Denotes that mentioned procedure should be executed after the annotated %test procedure. %rollback(<type>) Package/procedure Configure transaction control behaviour (type). Supported values: auto (default) - A savepoint is created before invocation of each \"before block\" is and a rollback to specific savepoint is issued after each \"after\" block; manual - rollback is never issued automatically. Property can be overridden for child element (test in suite) %disabled Package/procedure Used to disable a suite or a test","title":"Annotations description"},{"location":"userguide/annotations.html#using-automatic-rollbacks-in-tests","text":"By default, every test is isolated from other tests using savepoint. This solution is suitable for use-cases, where the code that is getting tested as well as the unit tests themselves do not use transaction control commands (commit/rollback). In general, your unit tests should not use transaction control as long as the core you are testing is not using it too. Keeping the transactions uncommitted allows your changes to be isolated and the execution of tests is not impacting others that might be using a shared (integration) development database. If however you're in situation, where the code you are testing, is using transaction control (like ETL code is usually doing), then your tests should not use the default rollback(auto) You should make sure that thr entire suitepath all the way to the root is using manual transaction control in that case. In some cases it is needed to perform DDL in setup/teardown. It is recommended to move such DDL statements to a procedure with pragma autonomous_transaction to eliminate implicit commit of the main session.","title":"Using automatic rollbacks in tests"},{"location":"userguide/annotations.html#suitepath-concept","text":"It is very likely that the application for which you are going to introduce tests consists of many different packages or procedures/functions. Usually procedures can be logically grouped inside a package, there also might be several logical groups of procedure in a single package or even packages themselves might relate to a common module. Lets say you have a complex insurance application the operates with policies, claims and payments. The payment module contains several packages for payment recognition, charging, planning etc. The payment recognition module among others contains a complex recognize_payment procedure that associates received money to the policies. If you want to create tests for your application it is recommended to structure your tests similarly to the logical structure of you application. So you end up with something like: * Integration tests * Policy tests * Claim tests * Payment tests * Payments recognition * Payments set off * Payouts The %suitepath annotation is used for such grouping. Even though test packages are defined in a flat structure the %suitepath is used by the framework to form a hierarchical structure of them. Your payments recognition test package might look like: create or replace package test_payment_recognition as -- %suite(Payment recognition tests) -- %suitepath(payments) -- %test(Recognize payment by policy number) procedure test_recognize_by_num ; -- %test -- %displayname(Recognize payment by payment purpose) procedure test_recognize_by_purpose ; -- %test(Recognize payment by customer) procedure test_recognize_by_customer ; end test_payment_recognition ; And payments set off test package: create or replace package test_payment_set_off as -- %suite(Payment set off tests) -- %suitepath(payments) -- %test(Set off creation test) procedure test_create_set_off ; -- %test -- %displayname(Set off annulation test) procedure test_annulate_set_off ; end test_payment_set_off ; When you execute tests for your application, the framework constructs test suite for each test package. Then in combines suites into grouping suites by the %suitepath annotation value so that the fully qualified path to the recognize_by_num procedure is USER:payments.test_payment_recognition.test_recognize_by_num . If any of its expectations fails then the test is marked as failed, also the test_payment_recognition suite, the parent suite payments and the whole run is marked as failed. The test report indicates which expectation has failed on the payments module. The payments recognition submodule is causing the failure as recognize_by_num has is not meeting the expectations of the test. Grouping tests into modules and submodules using the %suitepath annotation allows you to logically organize your projects flat structure of packages int functional groups. Additional advantage of such grouping is the fact that every element level of the grouping can be an actual unit test package containing module level common setup for all of the submodules. So in addition to the packages mentioned above you could have following package. create or replace package payments as -- %suite(Payments) -- %beforeall procedure set_common_payments_data ; -- %afterall procedure reset_common_paymnets_data ; end payments ; A %suitepath can be provided in tree ways: * schema - execute all test in the schema * [schema]:suite1[.suite2][.suite3]...[.procedure] - execute all tests in all suites from suite1[.suite2][.suite3]...[.procedure] path. If schema is not provided, then current schema is used. Example: :all.rooms_tests . * [schema.]package[.procedure] - execute all tests in the test package provided. The whole hierarchy of suites in the schema is build before, all before/after hooks of partn suites for th provided suite package are executed as well. Example: tests.test_contact.test_last_name_validator or simply test_contact.test_last_name_validator if tests is the current schema.","title":"Suitepath concept"},{"location":"userguide/best-practices.html","text":"Best Practices \u00b6 The following are best practices we as utPLSQL have learned about PL/SQL and Unit Testing. Test Interaction \u00b6 Tests should not depend on a specific order to run. Tests should not depend on other tests to execute. A developer should be able to run one or more tests of their choosing with out any prerequisites. Tests are not for production \u00b6 Tests generate will generate fake data, so it should go without saying. You should not deploy your tests to a production database. Tests and their relationship to code under test. \u00b6 Code that you want to test, and the tests should be in separate packages. Test code commonly will be the same schema as code Version Control \u00b6 Use a version control system for your code. Don't just trust the database for code storage. This includes both the code you have under test, and the unit tests you develop as well.","title":"Testing best pracitces"},{"location":"userguide/best-practices.html#best-practices","text":"The following are best practices we as utPLSQL have learned about PL/SQL and Unit Testing.","title":"Best Practices"},{"location":"userguide/best-practices.html#test-interaction","text":"Tests should not depend on a specific order to run. Tests should not depend on other tests to execute. A developer should be able to run one or more tests of their choosing with out any prerequisites.","title":"Test Interaction"},{"location":"userguide/best-practices.html#tests-are-not-for-production","text":"Tests generate will generate fake data, so it should go without saying. You should not deploy your tests to a production database.","title":"Tests are not for production"},{"location":"userguide/best-practices.html#tests-and-their-relationship-to-code-under-test","text":"Code that you want to test, and the tests should be in separate packages. Test code commonly will be the same schema as code","title":"Tests and their relationship to code under test."},{"location":"userguide/best-practices.html#version-control","text":"Use a version control system for your code. Don't just trust the database for code storage. This includes both the code you have under test, and the unit tests you develop as well.","title":"Version Control"},{"location":"userguide/coverage.html","text":"Coverage \u00b6 utPLSQL comes with build-in coverage reporting engine. The code coverage reporting is based off DBMS_PROFILER package. Code coverage is gathered for the following source types: * package bodies * type bodies * triggers * stored procedures * stored functions Note: The package specifications and type specifications are explicitly excluded from code coverage analysis.This limitation is introduced to avoid false-negatives. Most of the package specifications don't contain executable code. The only exception is initialization of global constants and variables in package specification.Since, most of package specifications are not executable at all, there is no information available on the number of lines covered and those would eb reported as 0% covered, which is not desired. To obtain information about code coverage of your Unit Tests, all you need to do is run your unit tests with one of build-in code coverage reporters. Following code coverage reporters are supplied with utPLSQL: * ut_coverage_html_reporter - generates a HTML coverage report providing summary and detailed information on code coverage. The html reporter is based on open-source simplecov-html reporter for Ruby. It includes source code of the code that was covered (if possible) * ut_coveralls_reporter - generates a JSON coverage report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by cloud services like coveralls * ut_coverage_sonar_reporter - generates a JSON coverage report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by local services like sonarqube Security model \u00b6 Code coverage is using DBMS_PROFILER to gather information about execution of code under test and therefore follows the DBMS_PROFILER's Security Model In order to be able to gather coverage information, user executing unit tests needs to be either: * Owner of the code that is tested * Have the following privileges to be able to gather coverage on code owned by other users: * create any procedure system privilege * execute privilege on the code that is tested (not only the unit tests) or execute any procedure system privilege If you have execute privilege on the code that are tested, but do not have create any procedure system privilege, the code that is tested will be reported as not covered (coverage = 0%). If you have execute privilege only on the unit tests, but do not have execute privilege on the code that is tested, the code will not be reported by coverage - as if it did not exist in the database. If the code that is testes is complied as NATIVE, the code coverage will not be reported as well. Running unite tests with coverage \u00b6 Using code coverage functionality is as easy as using any other reporter for utPLSQL project. All you need to do is run your tests from your preferred SQL tool and save the outcomes of reporter to a file. All you need to do, is pass the constructor of the reporter to your ut.run Example: begin ut . run ( ut_coverage_html_reporter ()); end ; / Executes all unit tests in current schema, gather information about code coverage and output the html text into DBMS_OUTPUT. The ut_coverage_html_reporter will produce a interactive HTML report. You may see a sample of code coverage for utPLSQL project here The report provides a summary information with list of source code that was expected to be covered. The report allow to navigate to every source and inspect line by line coverage. Coverage reporting options \u00b6 By default the database schema/schemes containing the tests that were executed during the run, are fully reported by coverage reporter. All valid unit tests are excluded from the report regardless if they were invoked or not. This way the coverage report is not affected by presence of tests and contains only the tested code. The default behavior of coverage reporters can be altered, depending on your needs. Including/excluding objects in coverage reports \u00b6 The most basic options are the include/exclude objects lists. You may specify both include and exclude objects lists to specify which objects are to be included in the report and which are to be excluded. Both of those options are meant to be used to narrow down the scope of unit test runs, that is broad by default. Example: exec ut . run ( 'ut3_user.test_award_bonus' , ut_coverage_html_reporter ( a_include_object_list => ut_varchar2_list ( 'ut3_user.award_bonus' ))); Executes test test_award_bonus and gather coverage only on object ut3_user.award_bonus Alternatively you could run: exec ut . run ( 'ut3_user.test_award_bonus' , ut_coverage_html_reporter ( a_exclude_object_list => ut_varchar2_list ( 'ut3_user.betwnstr' ))); Executes test test_award_bonus and gather on all objects in schema ut3_user except valid unit test objects and object betwnstr that schema. You can also combine the parameters and both will be applied. Defining different schema name(s) \u00b6 In some architectures, you might end up in a situation, where your unit tests exist in a different schema than the tested code. This is not the default or recommended approach but is supporter by utPLSQL. In such scenarios, you would probably have a separate database schema to hold unit tests and a separate schema/schemes to hold the tested code. Since by default, coverage reporting is done on the schema/schemes that the invoked tests are on, the code will not be included in coverage report as it is in a different schema than the invoked tests. In this situation you need to provide list of schema names that the tested code is in. This option overrides the default schema names for coverage. Example: exec ut . run ( 'ut3_user.test_award_bonus' , ut_coverage_html_reporter ( a_schema_names => ut_varchar2_list ( 'usr' ))); Executes test test_award_bonus in schema ut3_user and gather coverage for that execution on all non unit-test objects from schema usr . You can combine schema names with include/exclude parameters and all will be applied. The a_schema_names parameter takes precedence however, so if include list contains objects from other schemes, that will not be considered. Example: begin ut . run ( 'ut3_user.test_award_bonus' , ut_coverage_html_reporter ( a_schema_names => ut_varchar2_list ( 'usr' ), a_include_object_list => ut_varchar2_list ( 'usr.award_bonus' ), a_exclude_object_list => ut_varchar2_list ( 'usr.betwnstr' ) ) ); end ; Executes test test_award_bonus in schema ut3_user and gather coverage for that execution on award_bonus object from schema usr . The exclude list is of no relevance as it is not overlapping with include list. Working with projects and project files \u00b6 Both sonar and coveralls are utilities that are more project-oriented than database-centric. They report statistics and coverage for project files in version control system. Nowadays, most of database projects are moving away from database-centric approach towards project/product-centric approach. Coverage reporting of utPLSQL allows you to perform code coverage analysis for your project files. This feature is supported by all build-in coverage reporting formats. When using this invocation syntax, coverage is only reported for the provided files, so using project files as input for coverage is also a way of limiting the scope of coverage analysis. This syntax also allows usage of a_include_object_list and a_exclude_object_list as optional parameters to filter the scope of analysis. Reporting using externally provided file mapping One of ways to perform coverage reporting on your project files is to provide to the coverage reporter a list of file path/names along with mapping to corresponding object name and object type. Example: begin ut . run ( 'usr' , ut_coverage_html_reporter ( a_file_mappings => ut_coverage_file_mappings ( ut_coverage_file_mapping ( file_name => 'sources/hr/award_bonus.prc' , object_owner => 'usr' , object_name => 'award_bonus' , object_type => 'procedure' ), ut_coverage_file_mapping ( file_name => 'sources/hr/betwnstr.fnc' , object_owner => 'usr' , object_name => 'betwnstr' , object_type => 'function' ) ) ) ); end ; Executes all tests in schema usr and reports coverage for that execution on procedure award_bonus and function betwnstr . The coverage report is mapped-back to file-system object names with paths. Reporting using regex file mapping rule If file names and paths in your project follow a well established naming conventions, then you can use the predefined rule for mapping file names to object names or you can define your own rule and pass it to the coverage reporter at runtime. Example of running with predefined regex mapping rule. begin ut . run ( 'usr' , ut_coverage_html_reporter ( a_file_paths => ut_varchar2_list ( 'sources/hr/award_bonus.prc' , 'sources/hr/betwnstr.fnc' ) ) ); end ; The predefined rule is based on the following default values for parameters: * a_regex_pattern => '.*(\\\\|\\/)((\\w+)\\.)?(\\w+)\\.(\\w{3})' * a_object_owner_subexpression => 3 * a_object_name_subexpression => 4 * a_object_type_subexpression => 5 * a_file_to_object_type_mapping - defined in table below The predefined file extension to object type mappings file extension object type tpb type body pkb package body bdy package body trg trigger fnc function prc procedure Since package specification and type specifications are not considered by coverage, the file extensions for those objects are not included in the mapping. Examples of filename paths that will be mapped correctly using predefined rules. * [...]directory[/subdirectory[/...]]/object_name.(tpb|pkb|trg|fnc|prc) * [...]directory[/subdirectory[/...]]/schema_name.object_name.(tpb|pkb|trg|fnc|prc) * [...]directory[\\subdirectory[\\...]]\\object_name.(tpb|pkb|trg|fnc|prc) * [...]directory[\\subdirectory[\\...]]\\schema_name.object_name.(tpb|pkb|trg|fnc|prc) If file names in your project structure are not prefixed with schema name (like above), the coverage report will look for objects to match the file names in the current schema of the connection that was used to execute tests with coverage. If for whatever reasons you use a user and current schema that is different then schem that holds your project code, you should use a_schema_name parameter to inform coverage reporter about database schema to be used for object lookup. Example: begin ut . run ( 'usr' , ut_coverage_html_reporter ( a_schema_name => 'hr' , a_file_paths => ut_varchar2_list ( 'sources/hr/award_bonus.prc' , 'sources/hr/betwnstr.fnc' ) ) ); end ; If your project structure is different, you may define your own mapping rule using regex. Example: begin ut . run ( 'usr' , ut_coverage_html_reporter ( a_file_paths => ut_varchar2_list ( 'sources/hr/procedures/award_bonus.sql' , 'sources/hr/functions/betwnstr.sql' ), a_regex_pattern => '.*(\\\\|\\/)(\\w+)\\.(\\w+)\\.(\\w{3})' , a_object_owner_subexpression => 2 , a_object_type_subexpression => 3 , a_object_name_subexpression => 4 , a_file_to_object_type_mapping => ut_key_value_pairs ( ut_key_value_pair ( 'functions' , 'function' ), ut_key_value_pair ( 'procedures' , 'procedure' ) ) ); end ;","title":"Code coverage"},{"location":"userguide/coverage.html#coverage","text":"utPLSQL comes with build-in coverage reporting engine. The code coverage reporting is based off DBMS_PROFILER package. Code coverage is gathered for the following source types: * package bodies * type bodies * triggers * stored procedures * stored functions Note: The package specifications and type specifications are explicitly excluded from code coverage analysis.This limitation is introduced to avoid false-negatives. Most of the package specifications don't contain executable code. The only exception is initialization of global constants and variables in package specification.Since, most of package specifications are not executable at all, there is no information available on the number of lines covered and those would eb reported as 0% covered, which is not desired. To obtain information about code coverage of your Unit Tests, all you need to do is run your unit tests with one of build-in code coverage reporters. Following code coverage reporters are supplied with utPLSQL: * ut_coverage_html_reporter - generates a HTML coverage report providing summary and detailed information on code coverage. The html reporter is based on open-source simplecov-html reporter for Ruby. It includes source code of the code that was covered (if possible) * ut_coveralls_reporter - generates a JSON coverage report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by cloud services like coveralls * ut_coverage_sonar_reporter - generates a JSON coverage report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by local services like sonarqube","title":"Coverage"},{"location":"userguide/coverage.html#security-model","text":"Code coverage is using DBMS_PROFILER to gather information about execution of code under test and therefore follows the DBMS_PROFILER's Security Model In order to be able to gather coverage information, user executing unit tests needs to be either: * Owner of the code that is tested * Have the following privileges to be able to gather coverage on code owned by other users: * create any procedure system privilege * execute privilege on the code that is tested (not only the unit tests) or execute any procedure system privilege If you have execute privilege on the code that are tested, but do not have create any procedure system privilege, the code that is tested will be reported as not covered (coverage = 0%). If you have execute privilege only on the unit tests, but do not have execute privilege on the code that is tested, the code will not be reported by coverage - as if it did not exist in the database. If the code that is testes is complied as NATIVE, the code coverage will not be reported as well.","title":"Security model"},{"location":"userguide/coverage.html#running-unite-tests-with-coverage","text":"Using code coverage functionality is as easy as using any other reporter for utPLSQL project. All you need to do is run your tests from your preferred SQL tool and save the outcomes of reporter to a file. All you need to do, is pass the constructor of the reporter to your ut.run Example: begin ut . run ( ut_coverage_html_reporter ()); end ; / Executes all unit tests in current schema, gather information about code coverage and output the html text into DBMS_OUTPUT. The ut_coverage_html_reporter will produce a interactive HTML report. You may see a sample of code coverage for utPLSQL project here The report provides a summary information with list of source code that was expected to be covered. The report allow to navigate to every source and inspect line by line coverage.","title":"Running unite tests with coverage"},{"location":"userguide/coverage.html#coverage-reporting-options","text":"By default the database schema/schemes containing the tests that were executed during the run, are fully reported by coverage reporter. All valid unit tests are excluded from the report regardless if they were invoked or not. This way the coverage report is not affected by presence of tests and contains only the tested code. The default behavior of coverage reporters can be altered, depending on your needs.","title":"Coverage reporting options"},{"location":"userguide/coverage.html#includingexcluding-objects-in-coverage-reports","text":"The most basic options are the include/exclude objects lists. You may specify both include and exclude objects lists to specify which objects are to be included in the report and which are to be excluded. Both of those options are meant to be used to narrow down the scope of unit test runs, that is broad by default. Example: exec ut . run ( 'ut3_user.test_award_bonus' , ut_coverage_html_reporter ( a_include_object_list => ut_varchar2_list ( 'ut3_user.award_bonus' ))); Executes test test_award_bonus and gather coverage only on object ut3_user.award_bonus Alternatively you could run: exec ut . run ( 'ut3_user.test_award_bonus' , ut_coverage_html_reporter ( a_exclude_object_list => ut_varchar2_list ( 'ut3_user.betwnstr' ))); Executes test test_award_bonus and gather on all objects in schema ut3_user except valid unit test objects and object betwnstr that schema. You can also combine the parameters and both will be applied.","title":"Including/excluding objects in coverage reports"},{"location":"userguide/coverage.html#defining-different-schema-names","text":"In some architectures, you might end up in a situation, where your unit tests exist in a different schema than the tested code. This is not the default or recommended approach but is supporter by utPLSQL. In such scenarios, you would probably have a separate database schema to hold unit tests and a separate schema/schemes to hold the tested code. Since by default, coverage reporting is done on the schema/schemes that the invoked tests are on, the code will not be included in coverage report as it is in a different schema than the invoked tests. In this situation you need to provide list of schema names that the tested code is in. This option overrides the default schema names for coverage. Example: exec ut . run ( 'ut3_user.test_award_bonus' , ut_coverage_html_reporter ( a_schema_names => ut_varchar2_list ( 'usr' ))); Executes test test_award_bonus in schema ut3_user and gather coverage for that execution on all non unit-test objects from schema usr . You can combine schema names with include/exclude parameters and all will be applied. The a_schema_names parameter takes precedence however, so if include list contains objects from other schemes, that will not be considered. Example: begin ut . run ( 'ut3_user.test_award_bonus' , ut_coverage_html_reporter ( a_schema_names => ut_varchar2_list ( 'usr' ), a_include_object_list => ut_varchar2_list ( 'usr.award_bonus' ), a_exclude_object_list => ut_varchar2_list ( 'usr.betwnstr' ) ) ); end ; Executes test test_award_bonus in schema ut3_user and gather coverage for that execution on award_bonus object from schema usr . The exclude list is of no relevance as it is not overlapping with include list.","title":"Defining different schema name(s)"},{"location":"userguide/coverage.html#working-with-projects-and-project-files","text":"Both sonar and coveralls are utilities that are more project-oriented than database-centric. They report statistics and coverage for project files in version control system. Nowadays, most of database projects are moving away from database-centric approach towards project/product-centric approach. Coverage reporting of utPLSQL allows you to perform code coverage analysis for your project files. This feature is supported by all build-in coverage reporting formats. When using this invocation syntax, coverage is only reported for the provided files, so using project files as input for coverage is also a way of limiting the scope of coverage analysis. This syntax also allows usage of a_include_object_list and a_exclude_object_list as optional parameters to filter the scope of analysis. Reporting using externally provided file mapping One of ways to perform coverage reporting on your project files is to provide to the coverage reporter a list of file path/names along with mapping to corresponding object name and object type. Example: begin ut . run ( 'usr' , ut_coverage_html_reporter ( a_file_mappings => ut_coverage_file_mappings ( ut_coverage_file_mapping ( file_name => 'sources/hr/award_bonus.prc' , object_owner => 'usr' , object_name => 'award_bonus' , object_type => 'procedure' ), ut_coverage_file_mapping ( file_name => 'sources/hr/betwnstr.fnc' , object_owner => 'usr' , object_name => 'betwnstr' , object_type => 'function' ) ) ) ); end ; Executes all tests in schema usr and reports coverage for that execution on procedure award_bonus and function betwnstr . The coverage report is mapped-back to file-system object names with paths. Reporting using regex file mapping rule If file names and paths in your project follow a well established naming conventions, then you can use the predefined rule for mapping file names to object names or you can define your own rule and pass it to the coverage reporter at runtime. Example of running with predefined regex mapping rule. begin ut . run ( 'usr' , ut_coverage_html_reporter ( a_file_paths => ut_varchar2_list ( 'sources/hr/award_bonus.prc' , 'sources/hr/betwnstr.fnc' ) ) ); end ; The predefined rule is based on the following default values for parameters: * a_regex_pattern => '.*(\\\\|\\/)((\\w+)\\.)?(\\w+)\\.(\\w{3})' * a_object_owner_subexpression => 3 * a_object_name_subexpression => 4 * a_object_type_subexpression => 5 * a_file_to_object_type_mapping - defined in table below The predefined file extension to object type mappings file extension object type tpb type body pkb package body bdy package body trg trigger fnc function prc procedure Since package specification and type specifications are not considered by coverage, the file extensions for those objects are not included in the mapping. Examples of filename paths that will be mapped correctly using predefined rules. * [...]directory[/subdirectory[/...]]/object_name.(tpb|pkb|trg|fnc|prc) * [...]directory[/subdirectory[/...]]/schema_name.object_name.(tpb|pkb|trg|fnc|prc) * [...]directory[\\subdirectory[\\...]]\\object_name.(tpb|pkb|trg|fnc|prc) * [...]directory[\\subdirectory[\\...]]\\schema_name.object_name.(tpb|pkb|trg|fnc|prc) If file names in your project structure are not prefixed with schema name (like above), the coverage report will look for objects to match the file names in the current schema of the connection that was used to execute tests with coverage. If for whatever reasons you use a user and current schema that is different then schem that holds your project code, you should use a_schema_name parameter to inform coverage reporter about database schema to be used for object lookup. Example: begin ut . run ( 'usr' , ut_coverage_html_reporter ( a_schema_name => 'hr' , a_file_paths => ut_varchar2_list ( 'sources/hr/award_bonus.prc' , 'sources/hr/betwnstr.fnc' ) ) ); end ; If your project structure is different, you may define your own mapping rule using regex. Example: begin ut . run ( 'usr' , ut_coverage_html_reporter ( a_file_paths => ut_varchar2_list ( 'sources/hr/procedures/award_bonus.sql' , 'sources/hr/functions/betwnstr.sql' ), a_regex_pattern => '.*(\\\\|\\/)(\\w+)\\.(\\w+)\\.(\\w{3})' , a_object_owner_subexpression => 2 , a_object_type_subexpression => 3 , a_object_name_subexpression => 4 , a_file_to_object_type_mapping => ut_key_value_pairs ( ut_key_value_pair ( 'functions' , 'function' ), ut_key_value_pair ( 'procedures' , 'procedure' ) ) ); end ;","title":"Working with projects and project files"},{"location":"userguide/exception-reporting.html","text":"Exception handling and reporting \u00b6 The utPLSQL is responsible for handling exceptions wherever they occur in the test run. utPLSQL is trapping most of the exceptions so that the test execution is not affected by individual tests or test packages throwing an exception. The framework provides a full stacktrace for every exception that was thrown. The stacktrace is clean and does not include any utPLSQL library calls in it. To achieve rerunability, the ORA-04068, ORA-04061 exceptions are not handled and test execution will be interrupted if such exception is encountered. This is because of how Oracle behaves on those exceptions. Test execution can fail for different reasons. The failures on different exceptions are handled as follows: * A test package without body - each %test is reported as failed with exception, nothing is executed * A test package with invalid body - each %test is reported as failed with exception, nothing is executed * A test package with invalid spec - package is not considered a valid unit test package and is excluded from execution. When trying to run a test package with invalid spec explicitly, exception is raised. Only valid specifications are parsed for annotations * A test package that is raising an exception in %beforeall - each %test is reported as failed with exception, %test , %beforeeach , %beforetest , %aftertest and %aftereach are not executed. %afterall is executed to allow cleanup of whatever was done in %beforeall * A test package that is raising an exception in %beforeeach - each %test is reported as failed with exception, %test , %beforetest and %aftertest is not executed. The %aftereach and %afterall blocks are getting executed to allow cleanup of whatever was done in %before... blocks * A test package that is raising an exception in %beforetest - the %test is reported as failed with exception, %test is not executed. The %aftertest , %aftereach and %afterall blocks are getting executed to allow cleanup of whatever was done in %before... blocks * A test package that is raising an exception in %test - the %test is reported as failed with exception. The execution of other blocks continues normally * A test package that is raising an exception in %aftertest - the %test is reported as failed with exception. The execution of other blocks continues normally * A test package that is raising an exception in %aftereach - each %test is reported as failed with exception. * A test package that is raising an exception in %afterall - all blocks of the package are executed, as the %afterall is the last step of package execution. Exception in %afterall is not affecting test results. A warning with exception stacktrace is displayed in the summary Example of reporting with exception thrown in %beforetest : Remove rooms by name Removes a room without content in it (FAILED - 1) Does not remove room when it has content Raises exception when null room name given Failures: 1) remove_empty_room error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 39 ORA-06512: at line 6 Finished in ,039346 seconds 3 tests, 0 failed, 1 errored, 0 ignored. Example of reporting with exception thrown in %test : Remove rooms by name Removes a room without content in it (FAILED - 1) Does not remove room when it has content Raises exception when null room name given Failures: 1) remove_empty_room error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 48 ORA-06512: at line 6 Finished in ,035726 seconds 3 tests, 0 failed, 1 errored, 0 ignored. Example of reporting with exception thrown in %aftertest : Remove rooms by name Removes a room without content in it (FAILED - 1) Does not remove room when it has content Raises exception when null room name given Failures: 1) remove_empty_room error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 42 ORA-06512: at line 6 Finished in ,045523 seconds 3 tests, 0 failed, 1 errored, 0 ignored. Example of reporting with exception thrown in %aftereach : Remove rooms by name Removes a room without content in it (FAILED - 1) Does not remove room when it has content (FAILED - 2) Raises exception when null room name given (FAILED - 3) Failures: 1) remove_empty_room error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 31 ORA-06512: at line 6 2) room_with_content error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 31 ORA-06512: at line 6 3) null_room_name error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 31 ORA-06512: at line 6 Finished in ,034863 seconds 3 tests, 0 failed, 3 errored, 0 ignored. Example of reporting with exception thrown in %afterall : Remove rooms by name Removes a room without content in it Does not remove room when it has content Raises exception when null room name given Warnings: 1) test_remove_rooms_by_name - Afterall procedure failed: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 35 ORA-06512: at line 6 Finished in ,044902 seconds 3 tests, 0 failed, 0 errored, 0 ignored. 1 warning(s)","title":"Error handling and reporting"},{"location":"userguide/exception-reporting.html#exception-handling-and-reporting","text":"The utPLSQL is responsible for handling exceptions wherever they occur in the test run. utPLSQL is trapping most of the exceptions so that the test execution is not affected by individual tests or test packages throwing an exception. The framework provides a full stacktrace for every exception that was thrown. The stacktrace is clean and does not include any utPLSQL library calls in it. To achieve rerunability, the ORA-04068, ORA-04061 exceptions are not handled and test execution will be interrupted if such exception is encountered. This is because of how Oracle behaves on those exceptions. Test execution can fail for different reasons. The failures on different exceptions are handled as follows: * A test package without body - each %test is reported as failed with exception, nothing is executed * A test package with invalid body - each %test is reported as failed with exception, nothing is executed * A test package with invalid spec - package is not considered a valid unit test package and is excluded from execution. When trying to run a test package with invalid spec explicitly, exception is raised. Only valid specifications are parsed for annotations * A test package that is raising an exception in %beforeall - each %test is reported as failed with exception, %test , %beforeeach , %beforetest , %aftertest and %aftereach are not executed. %afterall is executed to allow cleanup of whatever was done in %beforeall * A test package that is raising an exception in %beforeeach - each %test is reported as failed with exception, %test , %beforetest and %aftertest is not executed. The %aftereach and %afterall blocks are getting executed to allow cleanup of whatever was done in %before... blocks * A test package that is raising an exception in %beforetest - the %test is reported as failed with exception, %test is not executed. The %aftertest , %aftereach and %afterall blocks are getting executed to allow cleanup of whatever was done in %before... blocks * A test package that is raising an exception in %test - the %test is reported as failed with exception. The execution of other blocks continues normally * A test package that is raising an exception in %aftertest - the %test is reported as failed with exception. The execution of other blocks continues normally * A test package that is raising an exception in %aftereach - each %test is reported as failed with exception. * A test package that is raising an exception in %afterall - all blocks of the package are executed, as the %afterall is the last step of package execution. Exception in %afterall is not affecting test results. A warning with exception stacktrace is displayed in the summary Example of reporting with exception thrown in %beforetest : Remove rooms by name Removes a room without content in it (FAILED - 1) Does not remove room when it has content Raises exception when null room name given Failures: 1) remove_empty_room error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 39 ORA-06512: at line 6 Finished in ,039346 seconds 3 tests, 0 failed, 1 errored, 0 ignored. Example of reporting with exception thrown in %test : Remove rooms by name Removes a room without content in it (FAILED - 1) Does not remove room when it has content Raises exception when null room name given Failures: 1) remove_empty_room error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 48 ORA-06512: at line 6 Finished in ,035726 seconds 3 tests, 0 failed, 1 errored, 0 ignored. Example of reporting with exception thrown in %aftertest : Remove rooms by name Removes a room without content in it (FAILED - 1) Does not remove room when it has content Raises exception when null room name given Failures: 1) remove_empty_room error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 42 ORA-06512: at line 6 Finished in ,045523 seconds 3 tests, 0 failed, 1 errored, 0 ignored. Example of reporting with exception thrown in %aftereach : Remove rooms by name Removes a room without content in it (FAILED - 1) Does not remove room when it has content (FAILED - 2) Raises exception when null room name given (FAILED - 3) Failures: 1) remove_empty_room error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 31 ORA-06512: at line 6 2) room_with_content error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 31 ORA-06512: at line 6 3) null_room_name error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 31 ORA-06512: at line 6 Finished in ,034863 seconds 3 tests, 0 failed, 3 errored, 0 ignored. Example of reporting with exception thrown in %afterall : Remove rooms by name Removes a room without content in it Does not remove room when it has content Raises exception when null room name given Warnings: 1) test_remove_rooms_by_name - Afterall procedure failed: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 35 ORA-06512: at line 6 Finished in ,044902 seconds 3 tests, 0 failed, 0 errored, 0 ignored. 1 warning(s)","title":"Exception handling and reporting"},{"location":"userguide/expectations.html","text":"Concepts \u00b6 Validation of the code under test (the tested logic of procedure/function etc.) is performed by comparing the actual data against the expected data. To do that we use concept of expectation and a matcher to perform the check on the data. It's best to give an example to get an idea what is what begin ut . expect ( 'the tested value' ). to_ ( equal ( 'the expected value' ) ); end ; Expectation is a set of the expected value(s), actual values(s) and the matcher(s) to run on those values. Matcher is defining the comparison operation to be performed on expected and actual values. Pseudo-code: ut . expect ( a_actual { data - type } ). to_ ( { matcher } ); ut . expect ( a_actual { data - type } ). not_to ( { matcher } ); Matchers \u00b6 utPLSQL provides following matchers to perform checks on the expected and actual values. - be_between - be_empty - be_false - be_greater_than - be_greater_or_equal - be_less_or_equal - be_less_than - be_like - be_not_null - be_null - be_true - equal - match be_between \u00b6 Validates that the actual value is between the lower and upper bound. Example: exec ut . expect ( a_actual => 3 ). to_ ( be_between ( a_lower_bound => 1 , a_upper_bound => 3 ) ); exec ut . expect ( 3 ). to_ ( be_between ( 1 , 3 ) ); be_empty \u00b6 Unary matcher that validates if the provided data-set is empty. Usage: declare l_cursor sys_refcursor ; begin open l_cursor for select * from dual where 1 = 0 ; ut . expect ( l_cursor ). to_ ( be_empty () ); end ; When used with anydata, it is only valid for collection data types. be_false \u00b6 Unary matcher that validates if the provided value is false. Usage: exec ut . expect ( ( 1 = 0 ) ). to_ ( be_false () ); be_greater_or_equal \u00b6 Allows to check if the actual value is greater or equal than the expected. Usage: exec ut . expect ( sysdate ). to_ ( be_greater_or_equal ( sysdate - 1 ) ); be_greater_than \u00b6 Allows to check if the actual value is greater than the expected. Usage: exec ut . expect ( 2 ). to_ ( be_greater_than ( 1 ) ); be_less_or_equal \u00b6 Allows to check if the actual value is less or equal than the expected. Usage: exec ut . expect ( 3 ). to_ ( be_less_or_equal ( 3 ) ); be_less_than \u00b6 Allows to check if the actual value is less than the expected. Usage: exec ut . expect ( 3 ). to_ ( be_less_than ( 2 ) ); be_like \u00b6 Validates that the actual value is like the expected expression. Usage: exec ut . expect ( 'Lorem_impsum' ). to_ ( be_like ( a_mask => '%rem\\_%' , a_escape_char => '\\' ) ); exec ut . expect ( 'Lorem_impsum' ). to_ ( be_like ( '%rem\\_%' , '\\' ) ); Parameters a_mask and a_escape_char represent a valid parameters of the Oracle like function be_not_null \u00b6 Unary matcher that validates if the actual value is not null. Usage: exec ut . expect ( to_clob ( 'ABC' ) ). to_ ( be_not_null () ); be_null \u00b6 Unary matcher that validates if the actual value is null. Usage: exec ut . expect ( cast ( null as varchar2 ( 100 )) ). to_ ( be_null () ); be_true \u00b6 Unary matcher that validates if the provided value is false. - boolean Usage: exec ut . expect ( ( 1 = 1 ) ). to_ ( be_true () ); equal \u00b6 The equal matcher is a very restrictive matcher. It only returns true, if compared data-types. That means, that comparing varchar2 to a number will fail even if the varchar2 contains the same number. This matcher is designed to capture changes of data-type, so that if you expect your variable to be number and is now something else, the test will fail and give you early indication of potential problem. Usage: declare x ref_cursor ; y ref_cursor ; begin ut . expect ( 'a dog' ). to_ ( equal ( 'a dog' ) ); ut . expect ( a_actual => y ). to_ ( equal ( a_expected => x , a_nulls_are_equal => true ) ); end ; The a_nulls_are_equal parameter decides on the behavior of null=null comparison ( this comparison by default is true! ) The anydata data type is used to compare user defined object and collections. Example usage of anydata to compare user defined types. create type department as object ( name varchar2 ( 30 )); / create or replace package demo_dept as -- %suite(demo) --%test(demo_dept) procedure test_department ; end ; / create or replace package body demo_dept as procedure test_department is v_expected department ; v_actual department ; begin v_expected : = department ( 'HR' ); ut . expect ( anydata . convertObject ( v_expected ) ). to_ ( equal ( anydata . convertObject ( v_actual ) ) ); end ; end ; / This test will fail as the v_acutal is not equal v_expected . match \u00b6 Validates that the actual value is matching the expected regular expression. Usage: exec ut . expect ( a_actual => '123-456-ABcd' ). to_ ( match ( a_pattern => '\\d{3}-\\d{3}-[a-z]' , a_modifiers => 'i' ) ); exec ut . expect ( 'some value' ). to_ ( match ( '^some.*' ) ); Parameters a_pattern and a_modifiers represent a valid regexp pattern accepted by Oracle regexp_like function Supported data types \u00b6 Below matrix illustrates the data types supported by different matchers. be_between be_empty be_false be_greater_than be_greater_or_equal be_less_or_equal be_less_than be_like be_not_null be_null be_true equal match anydata X X X X blob X X X boolean X X X X X clob X X X X X date X X X X X X X X number X X X X X X X X refcursor X X X X timestamp X X X X X X X X timestamp with timezone X X X X X X X X timestamp with local timezone X X X X X X X X varchar2 X X X X X X interval year to month X X X X X X X X interval day to second X X X X X X X X Negating the matcher \u00b6 Expectations provide a very convenient way to check for a negative of the expectation. Syntax of check for matcher evaluating to true: exec ut . expect ( a_actual { data - type } ). to_ ( { matcher } ); Syntax of check for matcher evaluating to false: exec ut . expect ( a_actual { data - type } ). not_to ( { matcher } ); If a matcher evaluated to NULL, then both to_ and not_to will cause the expectation to report failure. Example: begin ut . expect ( null ). to_ ( be_true () ); ut . expect ( null ). not_to ( be_true () ); end ; Since NULL is neither true not it is not true, both expectations will report failure.","title":"Expectations"},{"location":"userguide/expectations.html#concepts","text":"Validation of the code under test (the tested logic of procedure/function etc.) is performed by comparing the actual data against the expected data. To do that we use concept of expectation and a matcher to perform the check on the data. It's best to give an example to get an idea what is what begin ut . expect ( 'the tested value' ). to_ ( equal ( 'the expected value' ) ); end ; Expectation is a set of the expected value(s), actual values(s) and the matcher(s) to run on those values. Matcher is defining the comparison operation to be performed on expected and actual values. Pseudo-code: ut . expect ( a_actual { data - type } ). to_ ( { matcher } ); ut . expect ( a_actual { data - type } ). not_to ( { matcher } );","title":"Concepts"},{"location":"userguide/expectations.html#matchers","text":"utPLSQL provides following matchers to perform checks on the expected and actual values. - be_between - be_empty - be_false - be_greater_than - be_greater_or_equal - be_less_or_equal - be_less_than - be_like - be_not_null - be_null - be_true - equal - match","title":"Matchers"},{"location":"userguide/expectations.html#be_between","text":"Validates that the actual value is between the lower and upper bound. Example: exec ut . expect ( a_actual => 3 ). to_ ( be_between ( a_lower_bound => 1 , a_upper_bound => 3 ) ); exec ut . expect ( 3 ). to_ ( be_between ( 1 , 3 ) );","title":"be_between"},{"location":"userguide/expectations.html#be_empty","text":"Unary matcher that validates if the provided data-set is empty. Usage: declare l_cursor sys_refcursor ; begin open l_cursor for select * from dual where 1 = 0 ; ut . expect ( l_cursor ). to_ ( be_empty () ); end ; When used with anydata, it is only valid for collection data types.","title":"be_empty"},{"location":"userguide/expectations.html#be_false","text":"Unary matcher that validates if the provided value is false. Usage: exec ut . expect ( ( 1 = 0 ) ). to_ ( be_false () );","title":"be_false"},{"location":"userguide/expectations.html#be_greater_or_equal","text":"Allows to check if the actual value is greater or equal than the expected. Usage: exec ut . expect ( sysdate ). to_ ( be_greater_or_equal ( sysdate - 1 ) );","title":"be_greater_or_equal"},{"location":"userguide/expectations.html#be_greater_than","text":"Allows to check if the actual value is greater than the expected. Usage: exec ut . expect ( 2 ). to_ ( be_greater_than ( 1 ) );","title":"be_greater_than"},{"location":"userguide/expectations.html#be_less_or_equal","text":"Allows to check if the actual value is less or equal than the expected. Usage: exec ut . expect ( 3 ). to_ ( be_less_or_equal ( 3 ) );","title":"be_less_or_equal"},{"location":"userguide/expectations.html#be_less_than","text":"Allows to check if the actual value is less than the expected. Usage: exec ut . expect ( 3 ). to_ ( be_less_than ( 2 ) );","title":"be_less_than"},{"location":"userguide/expectations.html#be_like","text":"Validates that the actual value is like the expected expression. Usage: exec ut . expect ( 'Lorem_impsum' ). to_ ( be_like ( a_mask => '%rem\\_%' , a_escape_char => '\\' ) ); exec ut . expect ( 'Lorem_impsum' ). to_ ( be_like ( '%rem\\_%' , '\\' ) ); Parameters a_mask and a_escape_char represent a valid parameters of the Oracle like function","title":"be_like"},{"location":"userguide/expectations.html#be_not_null","text":"Unary matcher that validates if the actual value is not null. Usage: exec ut . expect ( to_clob ( 'ABC' ) ). to_ ( be_not_null () );","title":"be_not_null"},{"location":"userguide/expectations.html#be_null","text":"Unary matcher that validates if the actual value is null. Usage: exec ut . expect ( cast ( null as varchar2 ( 100 )) ). to_ ( be_null () );","title":"be_null"},{"location":"userguide/expectations.html#be_true","text":"Unary matcher that validates if the provided value is false. - boolean Usage: exec ut . expect ( ( 1 = 1 ) ). to_ ( be_true () );","title":"be_true"},{"location":"userguide/expectations.html#equal","text":"The equal matcher is a very restrictive matcher. It only returns true, if compared data-types. That means, that comparing varchar2 to a number will fail even if the varchar2 contains the same number. This matcher is designed to capture changes of data-type, so that if you expect your variable to be number and is now something else, the test will fail and give you early indication of potential problem. Usage: declare x ref_cursor ; y ref_cursor ; begin ut . expect ( 'a dog' ). to_ ( equal ( 'a dog' ) ); ut . expect ( a_actual => y ). to_ ( equal ( a_expected => x , a_nulls_are_equal => true ) ); end ; The a_nulls_are_equal parameter decides on the behavior of null=null comparison ( this comparison by default is true! ) The anydata data type is used to compare user defined object and collections. Example usage of anydata to compare user defined types. create type department as object ( name varchar2 ( 30 )); / create or replace package demo_dept as -- %suite(demo) --%test(demo_dept) procedure test_department ; end ; / create or replace package body demo_dept as procedure test_department is v_expected department ; v_actual department ; begin v_expected : = department ( 'HR' ); ut . expect ( anydata . convertObject ( v_expected ) ). to_ ( equal ( anydata . convertObject ( v_actual ) ) ); end ; end ; / This test will fail as the v_acutal is not equal v_expected .","title":"equal"},{"location":"userguide/expectations.html#match","text":"Validates that the actual value is matching the expected regular expression. Usage: exec ut . expect ( a_actual => '123-456-ABcd' ). to_ ( match ( a_pattern => '\\d{3}-\\d{3}-[a-z]' , a_modifiers => 'i' ) ); exec ut . expect ( 'some value' ). to_ ( match ( '^some.*' ) ); Parameters a_pattern and a_modifiers represent a valid regexp pattern accepted by Oracle regexp_like function","title":"match"},{"location":"userguide/expectations.html#supported-data-types","text":"Below matrix illustrates the data types supported by different matchers. be_between be_empty be_false be_greater_than be_greater_or_equal be_less_or_equal be_less_than be_like be_not_null be_null be_true equal match anydata X X X X blob X X X boolean X X X X X clob X X X X X date X X X X X X X X number X X X X X X X X refcursor X X X X timestamp X X X X X X X X timestamp with timezone X X X X X X X X timestamp with local timezone X X X X X X X X varchar2 X X X X X X interval year to month X X X X X X X X interval day to second X X X X X X X X","title":"Supported data types"},{"location":"userguide/expectations.html#negating-the-matcher","text":"Expectations provide a very convenient way to check for a negative of the expectation. Syntax of check for matcher evaluating to true: exec ut . expect ( a_actual { data - type } ). to_ ( { matcher } ); Syntax of check for matcher evaluating to false: exec ut . expect ( a_actual { data - type } ). not_to ( { matcher } ); If a matcher evaluated to NULL, then both to_ and not_to will cause the expectation to report failure. Example: begin ut . expect ( null ). to_ ( be_true () ); ut . expect ( null ). not_to ( be_true () ); end ; Since NULL is neither true not it is not true, both expectations will report failure.","title":"Negating the matcher"},{"location":"userguide/getting-started.html","text":"Getting Started \u00b6 TODO: A quick guide to writing your first unit test. This should not get into all the options available instead it should link to that documentation where it is appropriate. This really should be a high level look at the product. It should take the point of view of someone who has never written a unit test in any language.","title":"Getting Started"},{"location":"userguide/getting-started.html#getting-started","text":"TODO: A quick guide to writing your first unit test. This should not get into all the options available instead it should link to that documentation where it is appropriate. This really should be a high level look at the product. It should take the point of view of someone who has never written a unit test in any language.","title":"Getting Started"},{"location":"userguide/install.html","text":"Installation \u00b6 To simply install the utPLSQL into a new database schema and grant it to public, execute the script install_headless.sql . This will create a new user UT3 with password UT3 , grant all needed privileges to that user and create PUBLIC synonyms needed to sue the utPLSQL framework. Example invocation of the script from command line: cd source sqlplus admin/admins_password@xe @@install_headless.sql Recommended Schema \u00b6 It is recommended to install utPLSQL in it's own schema. You are free to choose any name for this schema. The installation user/schema must have the following Oracle system permissions during the installation. - CREATE SESSION - CREATE PROCEDURE - CREATE TYPE - CREATE TABLE - CREATE VIEW - CREATE SYNONYM - ALTER SESSION In addition it must be granted execute to the following system packages. DBMS_LOCK The utPLSQL is using Oracle DBMS_PROFILER tables . The tables will be created in the installation schema if they do not exist. The uninstall process however will not drop those tables, as they can potentially be shared and reused for profiling PLSQL code. It is up to DBA to maintain the storage of the profiler tables. Installation Procedure \u00b6 Creating schema for utPLSQL \u00b6 To create the utPLSQL schema and grant all the needed privileges execute script create_utplsql_owner.sql from the source directory with parameters: - user name - the name of the user that will own of utPLSQL object - password - the password to be set for that user - tablespace name - the tablespace name to hold data created during test execution Example invocation of the script from command line: cd source sqlplus admin/admins_password@xe @@create_utPLSQL_owner.sql ut3 ut3 users Installing utPLSQL \u00b6 To install the utPLSQL sources into your database run the /source/install.sql script and provide the schema name where utPLSQL is to be installed You need to install the utPLSQL sources into a already existing database schema. You may install it from any account that has sufficient privileges to create objects in other users schema. You may also choose to install it directly into the schema owning the package. Example invocation of the script from command line: cd source sqlplus admin/admins_password@xe @@install.sql ut3 Allowing other users to access utPLSQL framework \u00b6 In order to allow other users to access utPLSQL, synonyms must be created and grants need to be added. You have two options: - use public grants and synonyms, to allow any user to access the framework - use synonyms and grants for individual users to limit the access the the framework To grant utPLSQL to public execute the script source/create_synonyms_and_grants_for_public.sql and provide the provide schema name where utPLSQL is installed Example invocation of the script from command line: cd source sqlplus admin/admins_password@xe @@create_synonyms_and_grants_for_public.sql ut3 To grant utPLSQL to individual user execute the script source/create_synonyms_and_grants_for_user.sql and provide provide the schema name where utPLSQL is installed and user name to be granted Example invocation of the script from command line: cd source sqlplus admin/admins_password@xe @@create_synonyms_and_grants_for_user.sql ut3 hr The following tools that support the SQL Plus commands can be used to run the installation script - SQL Plus - SQLcl - Oracle SQL Developer Uninstalling utPLSQL \u00b6 To uninstall run /source/uninstall.sql and provide the provide schema name where utPLSQL is installed. The uninstall script will remove all the objects installed by the install script. Additionally, all the public and private synonyms pointing to the objects in utPLSQL schema will be removed. If you have you have extended any utPLSQL types such as a custom reporter, these will need to be dropped before the uninstall, otherwise the uninstall script might fail. In order for the uninstall to be successful, you need to use the uninstall script, that was provided wht the exact version that was installed on your database.","title":"Installation"},{"location":"userguide/install.html#installation","text":"To simply install the utPLSQL into a new database schema and grant it to public, execute the script install_headless.sql . This will create a new user UT3 with password UT3 , grant all needed privileges to that user and create PUBLIC synonyms needed to sue the utPLSQL framework. Example invocation of the script from command line: cd source sqlplus admin/admins_password@xe @@install_headless.sql","title":"Installation"},{"location":"userguide/install.html#recommended-schema","text":"It is recommended to install utPLSQL in it's own schema. You are free to choose any name for this schema. The installation user/schema must have the following Oracle system permissions during the installation. - CREATE SESSION - CREATE PROCEDURE - CREATE TYPE - CREATE TABLE - CREATE VIEW - CREATE SYNONYM - ALTER SESSION In addition it must be granted execute to the following system packages. DBMS_LOCK The utPLSQL is using Oracle DBMS_PROFILER tables . The tables will be created in the installation schema if they do not exist. The uninstall process however will not drop those tables, as they can potentially be shared and reused for profiling PLSQL code. It is up to DBA to maintain the storage of the profiler tables.","title":"Recommended Schema"},{"location":"userguide/install.html#installation-procedure","text":"","title":"Installation Procedure"},{"location":"userguide/install.html#creating-schema-for-utplsql","text":"To create the utPLSQL schema and grant all the needed privileges execute script create_utplsql_owner.sql from the source directory with parameters: - user name - the name of the user that will own of utPLSQL object - password - the password to be set for that user - tablespace name - the tablespace name to hold data created during test execution Example invocation of the script from command line: cd source sqlplus admin/admins_password@xe @@create_utPLSQL_owner.sql ut3 ut3 users","title":"Creating schema for utPLSQL"},{"location":"userguide/install.html#installing-utplsql","text":"To install the utPLSQL sources into your database run the /source/install.sql script and provide the schema name where utPLSQL is to be installed You need to install the utPLSQL sources into a already existing database schema. You may install it from any account that has sufficient privileges to create objects in other users schema. You may also choose to install it directly into the schema owning the package. Example invocation of the script from command line: cd source sqlplus admin/admins_password@xe @@install.sql ut3","title":"Installing utPLSQL"},{"location":"userguide/install.html#allowing-other-users-to-access-utplsql-framework","text":"In order to allow other users to access utPLSQL, synonyms must be created and grants need to be added. You have two options: - use public grants and synonyms, to allow any user to access the framework - use synonyms and grants for individual users to limit the access the the framework To grant utPLSQL to public execute the script source/create_synonyms_and_grants_for_public.sql and provide the provide schema name where utPLSQL is installed Example invocation of the script from command line: cd source sqlplus admin/admins_password@xe @@create_synonyms_and_grants_for_public.sql ut3 To grant utPLSQL to individual user execute the script source/create_synonyms_and_grants_for_user.sql and provide provide the schema name where utPLSQL is installed and user name to be granted Example invocation of the script from command line: cd source sqlplus admin/admins_password@xe @@create_synonyms_and_grants_for_user.sql ut3 hr The following tools that support the SQL Plus commands can be used to run the installation script - SQL Plus - SQLcl - Oracle SQL Developer","title":"Allowing other users to access utPLSQL framework"},{"location":"userguide/install.html#uninstalling-utplsql","text":"To uninstall run /source/uninstall.sql and provide the provide schema name where utPLSQL is installed. The uninstall script will remove all the objects installed by the install script. Additionally, all the public and private synonyms pointing to the objects in utPLSQL schema will be removed. If you have you have extended any utPLSQL types such as a custom reporter, these will need to be dropped before the uninstall, otherwise the uninstall script might fail. In order for the uninstall to be successful, you need to use the uninstall script, that was provided wht the exact version that was installed on your database.","title":"Uninstalling utPLSQL"},{"location":"userguide/reporters.html","text":"utPLSQL provides the following reporting formats. Documentation reporter \u00b6 The ut_documentation_reporter is the default reporting format used by the framework. It provides a human readable test results. To invoke tests with documentation reporter use one of following calls from sql console (SQLPlus) exec ut.run(); exec ut.run(ut_documentation_reporter()); You may also invoke unit tests directly from command line by calling. sqlplus /nolog @ut_run %user%/%pass%@%dbsid% Invoking tests from command line tool ut_run.sql allows you to track progress of test execution. In that case, the documentation reporter will provide information about each test that was executed as soon as it's execution finishes. For more details on using the ut_run.sql script look into ut_run.sql documentation. The ut_documentation_reporter doesn't accept any arguments. Example outputs from documentation reporter. The documentation report provides the following information. - Test suite name or test package name (nested with suitepath if suitepath is used) - Test description name or test procedure name - Information about test failing (FAILED - n) - Information about disabled test (IGNORED) - List of all errors and failures - Summary with total number of tests, number of tests with status and timing for the execution Color output from documentation reporter \u00b6 When invoking tests with documentation reporter and your command line supports ANSICONSOLE (default on Unix), you can obtain the coloured outputs from the documentation reporter. To invoke tests with documentation reporter in color mode use one of following calls. exec ut.run(a_color_console=>true); exec ut.run(ut_documentation_reporter(), a_color_console=>true); Example outputs from documentation reporter. XUnit reporter \u00b6 Most of continuous integration servers (like Jenkins) are capable of consuming unit test execution results in XUnit/JUnit format. The ut_xunit_reporter is producing outcomes as XUnit-compatible XML unit test report, that can be used by CI servers to display their custom reports and provide metrics (like tests execution trends). Invocation of tests with XUnit reporter. exec ut.run(ut_xunit_reporter()); The ut_xunit_reporter doesn't accept any arguments. Example of xunit report integrated with Jenkins CI Example of failure report details Teamcity reporter \u00b6 Teamcity is a CI server by Jetbrains. It supports XUnit reporting and additionally has it's own format of reporting that allows tracking of progress of a CI step/task as it executes. The TeamCity format developed by Jetbrains is supported by utPLSQL with ut_teamcity_reporter . Invocation of tests with Teamcity reporter. exec ut.run(ut_teamcity_reporter()); The ut_teamcity_reporter doesn't accept any arguments. Example of unit test report from Teamcity CI server. Example of failure report details Coverage reporters \u00b6 utPLSQL comes with a set of build-in coverage reporters. Have a look into the coverage documentation to learn more about them.","title":"Using reporters"},{"location":"userguide/reporters.html#documentation-reporter","text":"The ut_documentation_reporter is the default reporting format used by the framework. It provides a human readable test results. To invoke tests with documentation reporter use one of following calls from sql console (SQLPlus) exec ut.run(); exec ut.run(ut_documentation_reporter()); You may also invoke unit tests directly from command line by calling. sqlplus /nolog @ut_run %user%/%pass%@%dbsid% Invoking tests from command line tool ut_run.sql allows you to track progress of test execution. In that case, the documentation reporter will provide information about each test that was executed as soon as it's execution finishes. For more details on using the ut_run.sql script look into ut_run.sql documentation. The ut_documentation_reporter doesn't accept any arguments. Example outputs from documentation reporter. The documentation report provides the following information. - Test suite name or test package name (nested with suitepath if suitepath is used) - Test description name or test procedure name - Information about test failing (FAILED - n) - Information about disabled test (IGNORED) - List of all errors and failures - Summary with total number of tests, number of tests with status and timing for the execution","title":"Documentation reporter"},{"location":"userguide/reporters.html#color-output-from-documentation-reporter","text":"When invoking tests with documentation reporter and your command line supports ANSICONSOLE (default on Unix), you can obtain the coloured outputs from the documentation reporter. To invoke tests with documentation reporter in color mode use one of following calls. exec ut.run(a_color_console=>true); exec ut.run(ut_documentation_reporter(), a_color_console=>true); Example outputs from documentation reporter.","title":"Color output from documentation reporter"},{"location":"userguide/reporters.html#xunit-reporter","text":"Most of continuous integration servers (like Jenkins) are capable of consuming unit test execution results in XUnit/JUnit format. The ut_xunit_reporter is producing outcomes as XUnit-compatible XML unit test report, that can be used by CI servers to display their custom reports and provide metrics (like tests execution trends). Invocation of tests with XUnit reporter. exec ut.run(ut_xunit_reporter()); The ut_xunit_reporter doesn't accept any arguments. Example of xunit report integrated with Jenkins CI Example of failure report details","title":"XUnit reporter"},{"location":"userguide/reporters.html#teamcity-reporter","text":"Teamcity is a CI server by Jetbrains. It supports XUnit reporting and additionally has it's own format of reporting that allows tracking of progress of a CI step/task as it executes. The TeamCity format developed by Jetbrains is supported by utPLSQL with ut_teamcity_reporter . Invocation of tests with Teamcity reporter. exec ut.run(ut_teamcity_reporter()); The ut_teamcity_reporter doesn't accept any arguments. Example of unit test report from Teamcity CI server. Example of failure report details","title":"Teamcity reporter"},{"location":"userguide/reporters.html#coverage-reporters","text":"utPLSQL comes with a set of build-in coverage reporters. Have a look into the coverage documentation to learn more about them.","title":"Coverage reporters"},{"location":"userguide/running-unit-tests.html","text":"utPLSQL framework provides two main entry points to run unit tests from within database: - ut.run procedures and functions - ut_runner.run procedures Those two entry points differ in purpose and behavior. ut.run \u00b6 Package ut contains overloaded procedures and functions run . The run API is designed to be called directly by developer, when using IDE/SQL console to execute unit tests. The main benefit of using this API is it's simplicity. One-line call is enough to execute a set of tests form one or multiple schemes. The procedures execute specified tests and produces outputs to DBMS_OUTPUT using specified reporter The functions can only be used in SELECT statements. They execute specified tests and produce outputs as a pipelined data stream to be consumed by select satement. ut.run procedures \u00b6 Examples: alter session set current_schema = hr ; begin ut . run (); end ; Execute all tests in current schema ( HR ). begin ut . run ( 'HR' ); end ; Execute all tests in specified schema ( HR ). begin ut . run ( 'hr:com.my_org.my_project' ); end ; Execute all tests from all packages that are on the COM.MY_ORG.MY_PROJECT suitepath. Check the annotations documentation to find out about suitepaths and how they can be used to group test packages. begin ut . run ( 'hr.test_apply_bonus' ); end ; Execute all tests from package HR.TEST_APPLY_BONUS . begin ut . run ( 'hr.test_apply_bonus.bonus_cannot_be_negative' ); end ; Execute single test procedure HR.TEST_APPLY_BONUS.BONUS_CANNOT_BE_NEGATIVE . begin ut . run ( ut_varcahr2_list ( 'hr.test_apply_bonus' , 'cust' )); end ; Execute all tests from package HR.TEST_APPLY_BONUS and all tests from schema CUST . Using a list of items to execute allows you to execute a fine-grained set of tests. Note: ut_documentation_reporter is default reporter for all API's defined for running unit tests. The ut.run procedures and functions accept a_reporter attribute that defines the reporter to be used in the run. You can execute any set of tests with any of the predefined reporters. begin ut . run ( 'hr.test_apply_bonus' , ut_xunit_reporter ()); end ; Execute all tests from package HR.TEST_APPLY_BONUS and provide outputs to DBMS_OUTPUT using the XUnit reporter. For details on build-in reporters look at reporters documentation . ut.run functions \u00b6 The ut.run functions provide exactly the same functionality as the procedures. You may use the same sets of parameters with both functions and procedures. The only difference is the output of the results. Functions provide outputs as pipelined stream and therefore need to be executed as select statements. Example. select * from table ( ut . run ( 'hr.test_apply_bonus' , ut_xunit_reporter ())); ut_runner.run \u00b6 The ut_runner provides API for integrating utPLSQL with other products. Maven, Jenkins, SQL Develper, PL/SQL Developer, TOAD and others can leverage this API to call utPLSQL. The main difference as compared to ut.run API is that the ut_runner.run does not print outputs to the screen. ut_runner.run accepts multiple reporters. Each reporter produces outputs into a separate output (uniquely identified by output_id). Outputs of multiple reporters can be consumed in parallel. This allows for live reporting of test execution progress with threads and several database sessions. The concept is pretty simple. in the main thread (session), define the reporters to be used. Each reporter has it's output_id and so you need to extract and store those output_id's. as a separate thread, start the ut_runner.run and pass reporters with previously defined output_id's for each reporter start a separate thread and read outputs from ut_output_buffer.get_lines table function by providing the output_id defined in the main thread. ut_runner.run is internally used by the ut_run.sql script which is a utility for running tests with multiple reporters and provides parameters to save reporters results into individual files on the local file system.","title":"Running unit tests"},{"location":"userguide/running-unit-tests.html#utrun","text":"Package ut contains overloaded procedures and functions run . The run API is designed to be called directly by developer, when using IDE/SQL console to execute unit tests. The main benefit of using this API is it's simplicity. One-line call is enough to execute a set of tests form one or multiple schemes. The procedures execute specified tests and produces outputs to DBMS_OUTPUT using specified reporter The functions can only be used in SELECT statements. They execute specified tests and produce outputs as a pipelined data stream to be consumed by select satement.","title":"ut.run"},{"location":"userguide/running-unit-tests.html#utrun-procedures","text":"Examples: alter session set current_schema = hr ; begin ut . run (); end ; Execute all tests in current schema ( HR ). begin ut . run ( 'HR' ); end ; Execute all tests in specified schema ( HR ). begin ut . run ( 'hr:com.my_org.my_project' ); end ; Execute all tests from all packages that are on the COM.MY_ORG.MY_PROJECT suitepath. Check the annotations documentation to find out about suitepaths and how they can be used to group test packages. begin ut . run ( 'hr.test_apply_bonus' ); end ; Execute all tests from package HR.TEST_APPLY_BONUS . begin ut . run ( 'hr.test_apply_bonus.bonus_cannot_be_negative' ); end ; Execute single test procedure HR.TEST_APPLY_BONUS.BONUS_CANNOT_BE_NEGATIVE . begin ut . run ( ut_varcahr2_list ( 'hr.test_apply_bonus' , 'cust' )); end ; Execute all tests from package HR.TEST_APPLY_BONUS and all tests from schema CUST . Using a list of items to execute allows you to execute a fine-grained set of tests. Note: ut_documentation_reporter is default reporter for all API's defined for running unit tests. The ut.run procedures and functions accept a_reporter attribute that defines the reporter to be used in the run. You can execute any set of tests with any of the predefined reporters. begin ut . run ( 'hr.test_apply_bonus' , ut_xunit_reporter ()); end ; Execute all tests from package HR.TEST_APPLY_BONUS and provide outputs to DBMS_OUTPUT using the XUnit reporter. For details on build-in reporters look at reporters documentation .","title":"ut.run procedures"},{"location":"userguide/running-unit-tests.html#utrun-functions","text":"The ut.run functions provide exactly the same functionality as the procedures. You may use the same sets of parameters with both functions and procedures. The only difference is the output of the results. Functions provide outputs as pipelined stream and therefore need to be executed as select statements. Example. select * from table ( ut . run ( 'hr.test_apply_bonus' , ut_xunit_reporter ()));","title":"ut.run functions"},{"location":"userguide/running-unit-tests.html#ut_runnerrun","text":"The ut_runner provides API for integrating utPLSQL with other products. Maven, Jenkins, SQL Develper, PL/SQL Developer, TOAD and others can leverage this API to call utPLSQL. The main difference as compared to ut.run API is that the ut_runner.run does not print outputs to the screen. ut_runner.run accepts multiple reporters. Each reporter produces outputs into a separate output (uniquely identified by output_id). Outputs of multiple reporters can be consumed in parallel. This allows for live reporting of test execution progress with threads and several database sessions. The concept is pretty simple. in the main thread (session), define the reporters to be used. Each reporter has it's output_id and so you need to extract and store those output_id's. as a separate thread, start the ut_runner.run and pass reporters with previously defined output_id's for each reporter start a separate thread and read outputs from ut_output_buffer.get_lines table function by providing the output_id defined in the main thread. ut_runner.run is internally used by the ut_run.sql script which is a utility for running tests with multiple reporters and provides parameters to save reporters results into individual files on the local file system.","title":"ut_runner.run"},{"location":"userguide/upgrade.html","text":"How to upgrade from prior versions \u00b6 TODO: Finish this documentation.","title":"Upgrade utPLSQL"},{"location":"userguide/upgrade.html#how-to-upgrade-from-prior-versions","text":"TODO: Finish this documentation.","title":"How to upgrade from prior versions"},{"location":"userguide/ut_run-script.html","text":"The ut_run.sql script is designed to allow invocation of utPLSQL with multiple reporters. It allows saving of outcomes into multiple output files. It also facilitates displaying on screen unit test results while the execution is still ongoing. Current limit of script parameters is 39 Scrip invocation \u00b6 ut_run.sql user/password@database [-p=(ut_path|ut_paths)] [-c] [-f=format [-o=output] [-s] ...] Parameters \u00b6 user - username to connect as password - password of the user database - database to connect to -p=ut_path(s)- A path or a comma separated list of paths to unit test to be executed. The path can be in one of the following formats: schema[.package[.procedure]] schema:suite[.suite[.suite][...]][.procedure] Both formats can be mixed in the comma separated list. If only schema is provided, then all suites owner by that schema (user) are executed. If -p is omitted, the current schema is used. -f=format - A reporter to be used for reporting. Available options: -f=ut_documentation_reporter A textual pretty-print of unit test results (usually use for console output) -f=ut_teamcity_reporter A teamcity Unit Test reporter, that can be used to visualize progress of test execution as the job progresses. -f=ut_xunit_reporter A XUnit xml format (as defined at: http://stackoverflow.com/a/9691131 and at https://gist.github.com/kuzuha/232902acab1344d6b578) Usually used by Continuous Integration servers like Jenkins/Hudson or Teamcity to display test results. If no -f option is provided, the ut_documentation_reporter will be used. -o=output - file name to save the output provided by the reporter. If defined, the output is not displayed on screen by default. This can be changed with the -s parameter. If not defined, then output will be displayed on screen, even if the parameter -s is not specified. If more than one -o parameter is specified for one -f parameter, the last one is taken into consideration. -s - Forces putting output to to screen for a given -f parameter. -c - If specified, enables printing of test results in colors as defined by ANSICONSOLE standards Parameters -f, -o, -s are correlated. That is parameters -o and -s are defining outputs for -f. Examples of invocation using sqlplus from command line: sqlplus /nolog @ut_run hr/hr@xe -p=hr_test -f=ut_documentation_reporter -o=run.log -s -f=ut_teamcity_reporter -o=teamcity.xml All Unit tests from schema/package \"hr_test\" will be be invoked with two reporters: - ut_documentation_reporter - will output to screen and save it's output to file \"run.log\" - ut_teamcity_reporter - will save it's output to file \"teamcity.xml\" sqlplus /nolog @ut_run hr/hr@xe All Unit tests from schema \"hr\" will be be invoked with ut_documentation_reporter as a format and the results will be printed to screen","title":"Using the ut_run script"},{"location":"userguide/ut_run-script.html#scrip-invocation","text":"ut_run.sql user/password@database [-p=(ut_path|ut_paths)] [-c] [-f=format [-o=output] [-s] ...]","title":"Scrip invocation"},{"location":"userguide/ut_run-script.html#parameters","text":"user - username to connect as password - password of the user database - database to connect to -p=ut_path(s)- A path or a comma separated list of paths to unit test to be executed. The path can be in one of the following formats: schema[.package[.procedure]] schema:suite[.suite[.suite][...]][.procedure] Both formats can be mixed in the comma separated list. If only schema is provided, then all suites owner by that schema (user) are executed. If -p is omitted, the current schema is used. -f=format - A reporter to be used for reporting. Available options: -f=ut_documentation_reporter A textual pretty-print of unit test results (usually use for console output) -f=ut_teamcity_reporter A teamcity Unit Test reporter, that can be used to visualize progress of test execution as the job progresses. -f=ut_xunit_reporter A XUnit xml format (as defined at: http://stackoverflow.com/a/9691131 and at https://gist.github.com/kuzuha/232902acab1344d6b578) Usually used by Continuous Integration servers like Jenkins/Hudson or Teamcity to display test results. If no -f option is provided, the ut_documentation_reporter will be used. -o=output - file name to save the output provided by the reporter. If defined, the output is not displayed on screen by default. This can be changed with the -s parameter. If not defined, then output will be displayed on screen, even if the parameter -s is not specified. If more than one -o parameter is specified for one -f parameter, the last one is taken into consideration. -s - Forces putting output to to screen for a given -f parameter. -c - If specified, enables printing of test results in colors as defined by ANSICONSOLE standards Parameters -f, -o, -s are correlated. That is parameters -o and -s are defining outputs for -f. Examples of invocation using sqlplus from command line: sqlplus /nolog @ut_run hr/hr@xe -p=hr_test -f=ut_documentation_reporter -o=run.log -s -f=ut_teamcity_reporter -o=teamcity.xml All Unit tests from schema/package \"hr_test\" will be be invoked with two reporters: - ut_documentation_reporter - will output to screen and save it's output to file \"run.log\" - ut_teamcity_reporter - will save it's output to file \"teamcity.xml\" sqlplus /nolog @ut_run hr/hr@xe All Unit tests from schema \"hr\" will be be invoked with ut_documentation_reporter as a format and the results will be printed to screen","title":"Parameters"}]}